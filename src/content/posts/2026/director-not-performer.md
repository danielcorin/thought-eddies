---
title: 'Director, Not Performer'
createdAt: 2026-01-29T19:41:15.004Z
updatedAt: 2026-01-29T19:41:15.004Z
editor: tarn
location: 'Brooklyn'
draft: false
series: Coding with Agents
---

What is it to build software with coding agents?
It's something distinctly different than writing code by hand.

One of my past, personal struggles with software was that I always had ideas for what I wanted to build.
Game concepts, personal tools, articulations or variations on well known and nascent concepts.
For more than a decade I tried, on and off, to build these little projects.
But more often than not, I got stuck before reaching the endpoint I had in mind.

The process was time-consuming and frustrating.
Often what drove me away was the feeling I was "working".
Working in the sense that I felt like I was at work, doing my job, as a software engineer.
I didn't want to slog through difficult debugging in my free time.
There are parts of software engineering that I find fun, but this was never one of them.

I was never inspired by the chance to learn another programming language or framework.
I witnessed my peers and the culture doing this often.
I tried to play that part, but it was never a true affinity of mine.
My creativity was constrained by my level of skill at producing code syntax.

I think language models and more recently coding agents taught me that I _don't_ like to write code most of the time.
What I like is the construction of an experience on a computer that is just how I want it.

The emergence of coding agents has changed the balance of building software entirely.
The shift has been one from performer to director.
From instrumentalist to composer.
From drawing to sculpting.

With a blank page, I always struggled to find traction.
But with a hunk of clay, I begin to sculpt.

I've been using language models to produce most of my code for about two years now.
The most meaningful jump I can recall was the release of `claude-3.5-sonnet`, but even before then, I was using a hybrid of Cursor chat and <kbd>âŒ˜</kbd><kbd>K</kbd> with `gpt-3.5-turbo` to swoop and tease my way through projects in languages and frameworks with which I was only loosely familiar.
The model made plenty of mistakes, but I had the debugging foundations to solve the problems the models couldn't.
And most importantly, I was moving forward and seeing progress.
Building in languages I haven't classically learned, shipping things I actually wanted to use.

I finally have a tool that operates at the level of abstraction that I do.
I need only to roughly articulate an idea in words to visualize and play with the shape of it.
I can poke, refine, and tweak.
Sand rough edges, polish and finish.

This shift in approach has been transformational.
I know I will never return to prior methods of assembling software.
Even running a model locally is better than the prior status quo.
And I have never had so much energy to work on my own projects.

There is an ongoing debate about whether agent coding can be relied upon to replace traditional software engineering techniques entirely.
I would argue this focus misses the change that has occurred.
Agent coding unlocks a new type of software that can be written, at every level of skill of computer use.
It used to be impractical to spend `x` hours building a personal recipe app.
Now it takes those same `x` hours spread across sessions and most of the time is waiting for the agent to finish its work, then you validate the parts you care about.

This hands-off approach isn't going to replace traditional software engineering techniques without significant changes in the way we think about the engineering process.
Maybe that will happen with time.
But today, it has made this new type of [home-cooked software](https://maggieappleton.com/home-cooked-software) highly accessible.
For a good result, you need to articulate what you want clearly, you need to verify the result works correctly, and you need to be persistent.
It's still _effortful_, but the agent-driven coding process is the order of magnitude change that was needed to shift the software-building status quo.
